import png
import StringIO
import binascii
import struct
import zlib

def mod(h, w, i, ov):
	CRC_SZ = 4
	idx = ov.index('IHDR') + len('IHDR')
	hdr = struct.pack('>i', w) + struct.pack('>i', h) + ov[idx + 8:idx + 8 + 4] + chr(int(i))
	crc = binascii.crc32('IHDR' + hdr)
	if crc < 0:
		crc += 0x100000000
	return ov[:idx] + hdr + struct.pack('>I', crc) + ov[idx+len(hdr)+CRC_SZ:]

def s_mod(ov, off):
	l = ov.index('IDAT')
	sz = struct.unpack('>I', ov[l-4:l])[0]
	rd = ov[l+len('IDAT'):l+len('IDAT')+sz]
	d = zlib.decompress(rd)
	nd = 'IDAT' + zlib.compress(d[:off], 0)
	crc = binascii.crc32(nd)
	if crc < 0:
		crc += 0x100000000
	return ov[:l-4] + struct.pack('>I', len(nd)) + nd + struct.pack('>I', crc) + ov[l+4+sz+4:]

def genall(var, special=False):
	t = var[0]
	var[0] = var[2]
	var[2] = t
	im = []
	# f = open('gen.png', 'wb')
	xx = 2561
	yy = 2560
	bb = 1
	ovr = [var]
	if special:
		xx = 1667
		bb = 3
		yy = 1664
		ovr = [[0x60, 0, 0, 0xff], [0xff, 0xff, 0xff, 0xff], var]
	p = png.Writer(1, xx, greyscale=False, compression=0, bitdepth=8, alpha=True, interlace=False)
	d = [[0xff, 0xff, 0xff, 0x78] for i in range(xx - bb)]
	for ov in ovr:
		d.append(ov)
	o = StringIO.StringIO()
	p.write(o, d)
	ov = mod(0x10000+yy, 1, False, o.getvalue())
	# 
	# ov = o.getvalue()
	# ov = s_mod(ov, 0x16c0+8)
	im.append(ov)
	im.append(ov)

	tmp = ov

	# open('lmao.png', 'wb+').write(ov)


	p = png.Writer(0x100, 7, greyscale=False, compression=0, bitdepth=8, alpha=True, interlace=False)
	d = [[0x0, 0x0, 0x0, 0x0]*0x100 for i in range(7)]
	o = StringIO.StringIO()
	p.write(o, d)
	ov = o.getvalue()
	im.append(ov)
	# im.append(ov)
	# im.append(ov)
	# im.append(ov)

	# im.append(tmp)
	rinfo = [(0x41,0x42,1),(0x43,0x44,2)]#,(0x45,0x46,3),(0x47,0x48,4)]

	t = open('template.ttf', 'rb')
	td = t.read()

	gh = struct.pack('>h', 0) + struct.pack('>h', 0) + 'png '
	im = [gh + ov for ov in im]

	tl = sum(len(ov) for ov in im)
	b = 0x10 + (len(im) - 1) * 4
	print b
	of = struct.pack('>i', b)
	for ov in im:
		b += len(ov)
		of += struct.pack('>i', b)

	ls = of[-4:]
	of += ls


	# td = td.replace('\x03\x20\x00\x5a\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x02', '\x03\x20\x00\x5a\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00' + struct.pack('>h', len(im) + 1))
	# td = td.replace('\x00\x00\x00\x10\x00\x00\x00\xc8\x00\x00\x00\xd0', of)
	td = td[:0x1c0] + struct.pack('>h', len(im) + 1) + td[0x1c2:]
	td = td[:0x21c] + of
	od = td + ''.join(im)
	tl = len(od) - 0x20c
	# td = td.replace('\x00\x00\x02\x0c\x00\x00\x01\x9d', struct.pack('>i', 0x20c) + struct.pack('>i', tl))
	rl = len(im) + 1
	if ((len(im) + 1)*2)%4 == 0:
		rl = len(im) + 2
	td = td[:0x206] + '\x00\x00' * rl + td[0x20c:]
	td = td[:0xb4] + struct.pack('>i', 0x206 + (rl * 2)) + td[0xb8:]
	td = td[:0xa8] + struct.pack('>i', 0x22 + (len(im) + 1) * 2) + td[0xa8+4:]
	td = td[:0xb8] + struct.pack('>i', tl) + td[0xb8+4:]
	td = td[:0x1a4] + struct.pack('>i', len(im) + 1) + td[0x1a8:]
	td = td[:0x204] + struct.pack('>h', len(im) + 1) + td[0x206:]
	td = td[:0x68] + struct.pack('>i', (len(im) + 1) * 4) + td[0x6c:]
	tfl = len(td + ''.join(im))
	pd = 4-(tfl%4) if tfl%4 else 0
	td = td[:0x64] + struct.pack('>i', tfl+pd) + td[0x68:]
	ap = pd * '\x00' + '\x03\x20\x00\x5a' * (len(im) + 1)
	tfl = len(td + ''.join(im) + ap)
	td = td[:0x74] + struct.pack('>i', tfl)  + struct.pack('>i', (len(im) + 2) * 2) + td[0x7c:]
	ap += '\x00' * ((len(im) + 2) * 2)
	tfl = len(td + ''.join(im) + ap)
	if tfl%4:
		ap += '\x00' * 2

	cmaph = struct.pack('>H', 0) + struct.pack('>H', 1)
	cmaph += struct.pack('>H', 3) + struct.pack('>H', 10) + struct.pack('>I', 12)
	cmap = struct.pack('>H', 13) + struct.pack('>H', 0) + struct.pack('>I', 0x1337) + struct.pack('>I', 0) + struct.pack('>I', len(rinfo))
	for r in rinfo:
		b,e,idx = r
		cmap += struct.pack('>I', b) + struct.pack('>I', e) + struct.pack('>I', idx)
	# cmap += struct.pack('>I', 0x61) + struct.pack('>I', 0x61+26) + struct.pack('>I', 2)

	cmapl = len(cmap)
	cmap = cmap[:4] + struct.pack('>I', cmapl) + cmap[8:]
	cmaptl = len(cmaph + cmap)
	tfl = len(td + ''.join(im) + ap)
	td = td[:0x24] + struct.pack('>I', tfl) + struct.pack('>I', cmaptl) + td[0x2c:]
	ap += cmaph + cmap


	od = td + ''.join(im) + ap
	return od